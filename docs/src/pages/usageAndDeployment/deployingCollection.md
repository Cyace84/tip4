# Deploying Collection

<div class="deployToken">

In this section, we will explore the process of deploying the `CollectionWithRoyalty` contract. As explained earlier in the [Collection](../specification/collection.md) section, the `CollectionWithRoyalty` contract inherits from other TIP4 Collection contracts and combines all the functionalities of the inherited contracts into one.

These mentioned collection contracts will provide us with the foundational functionality of the existing NFT standards, along with an additional feature called  [`Indexing`](../specification/tip4_3.md). Follow the steps below to learn how to deploy the collection contract:

## Step 1: Prepare the Contracts

### Build the Contracts Artifacts

run the command below into your terminal to build the mentioned contracts in the [Locklift Config Setup](../gettingStarted/lockliftConfigSetup.md) artifacts in your `locklift project`:

````shell

npx locklift build

````

### Store Contracts Code and tvc

In order to deploy a contract using the `everscale-inpage-provider` tool we need the target contracts code and tvc.

Copy the build folder generated by the mentioned build command into the scripts folder of your `everscale-inpage-provider` project.


## Step 2: Write Deployment Script

<span  :class="LLdis"  >

The code sample below written in `TS` will deploy the `CollectionWithRoyalty` contract with the help of the `Locklift` tool.

::: info
Before we start to write our scripts we need to make sure that there is a file named `01-deploy-base-collection.ts` in the `script` folder in the project root.
:::

</span>

<span :class="EIPdis"  >

The code sample below is utilized to deploy the `CollectionWithRoyalty` contract using `everscale-inpage-provider` tool.

</span>

<div @click="codeBlockSwitchHandler" >

::: code-group

```` typescript [locklift]

// Import the following libraries
import { Account, Signer } from "everscale-standalone-client";
import { Address, Contract, WalletTypes, zeroAddress } from "locklift";
import { FactorySource } from "../build/factorySource";

// Prepare the collection json metadata
const collectionJsonMetadata: string = JSON.stringify({
  type: "Basic NFT",
  name: "hell bite",
  description: "The red daemons from hell",
  preview: {
    source:
      "https://images.pexels.com/photos/16115934/pexels-photo-16115934/free-photo-of-spooky-traditional-figurine.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1",
    mimetype: "image/JPEG",
  },
  files: [
    {
      source:
        "https://images.pexels.com/photos/16115934/pexels-photo-16115934/free-photo-of-spooky-traditional-figurine.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1",
      mimetype: "image/JPEG",
    },
  ],
  external_url: "https://images.pexels.com",
});

async function main() {

  // Fetching the signer key pair from locklift.config.ts
  const signer: Signer = (await locklift.keystore.getSigner("0"))!;

  // uncomment if deploying a new account
  // const { contract: Account } = await locklift.factory.deployContract({
  //   contract: "Account",
  //   publicKey: signer.publicKey,
  //   constructorParams: {},
  //   initParams: { _randomNonce: locklift.utils.getRandomNonce() },
  //   value: locklift.utils.toNano(20),
  // });

  // Adding an existing SafeMultiSig Account using its address
  const account: Account = await locklift.factory.accounts.addExistingAccount({
    type: WalletTypes.MsigAccount,
    address: new Address("YOUR_ACCOUNT_ADDRESS"), // if deploying new account >> Account.address
    mSigType: "SafeMultisig",
    publicKey: signer.publicKey,
  });

  // Storing the "Index" and "IndexBasis" codes which are required to be passed to the collectionWithRoyalty contract constructor.
  const indexCode = locklift.factory.getContractArtifacts("Index").code;
  const indexBasisCode = locklift.factory.getContractArtifacts("IndexBasis").code;

  /**
   *  Deploying the CollectionWithRoyalty contract.
   * @param remainOnNft The number of the gas tokens that will stay on the nft contract after the minting process is done.
   */
  const { contract: collectionContract } = await locklift.factory.deployContract({
    contract: "CollectionWithRoyalty",
    publicKey: signer.publicKey,
    constructorParams: {
      codeNft: locklift.factory.getContractArtifacts("NftWithRoyalty").code,
      owner: account.address,
      json: collectionJsonMetadata,
      codeIndex: indexCode,
      codeIndexBasis: indexBasisCode,
      remainOnNft: locklift.utils.toNano("2"),
    },
    initParams: {
      nonce_: locklift.utils.getRandomNonce(),
    },
    value: locklift.utils.toNano(10),
  });

  console.log(`collection deployed to: ${collectionContract.address.toString()}`);

}
main()
  .then(res => {
    process.exit(0);
  })
  .catch(err => {
    console.log(err.message);
    process.exit(1);
  });

````

````typescript [everscale-inpage-provider]

// Import the following libraries
import {
  Address,
  GetExpectedAddressParams,
  Contract,
  ProviderApiResponse,
  FullContractState,
  ProviderRpcClient,
  Transaction
} from "everscale-inpage-provider";

import { factorySource, FactorySource } from "./build/factorySource";
import { useProviderInfo } from "./helpers/useProviders";

// Prepare the nft json metadata
const collectionJsonMetadata: string = JSON.stringify({
  type: "Basic NFT",
  name: "Daemon #1",
  description: "The red daemons from hell",
  preview: {
    source:
      "https://images.pexels.com/photos/16115934/pexels-photo-16115934/free-photo-of-spooky-traditional-figurine.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1",
    mimetype: "image/JPEG",
  },
  files: [
    {
      source:
        "https://images.pexels.com/photos/16115934/pexels-photo-16115934/free-photo-of-spooky-traditional-figurine.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1",
      mimetype: "image/JPEG",
    },
  ],
  external_url: "https://images.pexels.com",
  image: "/1.jpeg",
  attributes: [
    { trait_type: "Background", value: "hell" },
    { trait_type: "Skin Color", value: "red" },
    { trait_type: "teeth", value: "sharp white" },
    { trait_type: "nationality", value: "utbvir" },
    { trait_type: "jewelry", value: "fire water fire" },
    { trait_type: "crown", value: "golden" },
    { trait_type: "Rarity Rank", value: 1 },
  ],
});

export async function main(){
  try {

    // Fetching the provider info from the module we made in the perquisites section
    const [provider, providerAddress]: [ProviderRpcClient, Address] =
      await useProviderInfo();

    // Storing the CollectionWithRoyalty contract abi
    const collectionAbi: FactorySource["CollectionWithRoyalty"] =
      factorySource["CollectionWithRoyalty"];

    // Define the deployParams type
    type DeployParams<Abi> = GetExpectedAddressParams<Abi> & {
      publicKey: string | undefined;
    };

    // Fetching the user public key
    const accountFullState: FullContractState = (
      await provider.getFullContractState({ address: providerAddress })
    ).state!;
    const senderPublicKey: string = await provider.extractPublicKey(
      accountFullState.boc
    );

    /**
      Fetching and storing the tvc and calculating the the codes of the mentioned contracts.
      @notice The replace() function is utilized to avoid any line breaks because of the back slashes in the .base64(tvc) files
    */

    // Fetching the tvc files from build folder that we provided for the project by copying it from our locklift project.
    const collectionTvc: string = await (
      await fetch("/path/to/build/CollectionWithRoyalty.base64")
    ).text();
    const nftTvc: string = (
      await (await fetch("/path/to/build/NftWithRoyalty.base64")).text()
    ).replace(/\r?\n|\r/g, "");
    const indexTvc: string = (
      await (await fetch("/path/to/build/Index.base64")).text()
    ).replace(/\r?\n|\r/g, "");
    const indexBasisTvc: string = (
      await (await fetch("/path/to/build/IndexBasis.base64")).text()
    ).replace(/\r?\n|\r/g, "");

    // Calculating the codes of the contracts.
    const nftCode: string = (await provider.splitTvc(nftTvc)).code!;
    const indexCode: string = (await provider.splitTvc(indexTvc)).code!;
    const indexBasisCode: string = (await provider.splitTvc(indexBasisTvc))
      .code!;

    /**
     * Preparing deploy params to build the state init with the contract abi
     */
    const deployParams: DeployParams<FactorySource["CollectionWithRoyalty"]> = {
      tvc: collectionTvc,
      workchain: 0,
      publicKey: senderPublicKey,
      initParams: {
        nonce_: (Math.random() * 6400) | 0,
      },
    };

    // Get the expected contract address
    const collectionExpectedAddress: Address = await provider.getExpectedAddress(
      collectionAbi,
      deployParams
    );

    // Get the state init
    const stateInit: ProviderApiResponse<"getExpectedAddress"> =
      await provider.getStateInit(collectionAbi, deployParams);
    stateInit.stateInit;

    // Send the coins to the calculated address
    await provider.sendMessage({
      sender: providerAddress,
      recipient: collectionExpectedAddress,
      amount: String(2 * 10 ** 9),
      bounce: false, // it's important to set this param to keep the evers in the contract
      stateInit: stateInit.stateInit,
    });

    // Create a contract instance, notice at this stage the collection contract is in the "uninit" status.
    const collectionContract: Contract<FactorySource["CollectionWithRoyalty"]> =
      new provider.Contract(collectionAbi, collectionExpectedAddress);

    // Calling the contracts constructor and changing its status from "uninit" to "active"
    const { transaction: deployRes } = await collectionContract.methods
      .constructor({
        codeNft: nftCode,
        owner: providerAddress,
        json: collectionJsonMetadata,
        codeIndex: indexCode,
        codeIndexBasis: indexBasisCode,
        remainOnNft: String(2 * 10 ** 9),
      })
      .sendExternal({
        stateInit: stateInit.stateInit,
        publicKey: deployParams.publicKey!,
      });

    // checking if the collection contract is deployed by fetching its "totalSupply", must be zero.
    const totalSupply: string = (
      await collectionContract.methods.totalSupply({ answerId: 0 }).call()
    ).count;

    if (totalSupply == "0") {
      console.log(`Collection deployed to ${collectionExpectedAddress.toString()}`);
    } else {
      console.log( `Collection deployment failed ! ${
        (deployRes.exitCode, deployRes.resultCode)
      }`);
    }
  } catch (err: any) {
    console.log(err.message);
  }
}



````

:::

</div>


<div class="action">

## Step 3: Deploy the CollectionWithRoyalty

<div :class="llAction">

Use this command to deploy CollectionWithRoyalty contract:

```shell
npx locklift run -s ./scripts/01-deploy-base-collection.ts
```
<ImgContainer src= '/deployingBaseCollection.png' width="100%" altText="deployTip3Output" />

Congratulations, you have successfully deployed collection contract using the TIP4 standard 🎉

</div>

<div :class="eipAction" >

<label class="container collectionMetaCheck"> Use default metadata
<input class="checkboxInput" ref="actionCollectionMetaDefault" type="checkbox" @click="defaultMetaHandler" checked="true">
<span class="checkmark"></span>
</label>

<textarea style="resize:none;" ref="actionCollectionMeta" :class="collMeta" type="text" placeholder="collection json metadata"></textarea>

<button @click="deployCollection" class="deployTokenBut" >deploy collection</button>

<p id="output-p" :class="EIPdis"><loading :text="loadingText"/></p>

</div>

</div>

</div>

<script lang="ts" >
import { defineComponent, ref, onMounted } from "vue";
import {toast} from "/src/helpers/toast";
import ImgContainer from "../../../.vitepress/theme/components/shared/BKDImgContainer.vue"
import loading from "../../../.vitepress/theme/components/shared/BKDLoading.vue"
import {deployBaseCollection} from "../../scripts/deployingBaseCollection";
import { IRoyaltyStructure } from "../../scripts/types";

export default defineComponent({
  name: "deployToken",
      components :{
    ImgContainer,
    loading
  },
  data(){
    return{
        LLdis: "cbShow",
        EIPdis: "cbHide",
        llAction: "llAction cbShow",
        eipAction: "eipAction cbHide",
        collMeta: "cbHide",
        nftMeta: "cbHide",
        loadingText: " ",
        loadingText2: " "
        }
  },
  setup() {

  async function defaultMetaHandler(e){
        if(e.target.checked){

        if(e.target.parentElement.className.includes("collectionMetaCheck"))
         {
            this.collMeta = "cbHide"
         } else if(e.target.parentElement.className.includes("nftMetaCheck"))
         {
            this.nftMeta = "cbHide"
         }
        }else{

        if(e.target.parentElement.className.includes("collectionMetaCheck"))
         {
            this.collMeta = "action Ain"
         } else if(e.target.parentElement.className.includes("nftMetaCheck"))
         {
            this.nftMeta = "action Ain"
         }
        }

    }
  async function deployCollection(){
        this.loadingText = ""
        if (
            !this.$refs.actionCollectionMetaDefault.checked &&
            this.$refs.actionCollectionMeta.value == ''

        ){
            toast("Collection metadata field is required !", 0)
            this.loadingText = "Failed"
            return
        }
        let deployTokenRes;
        if(this.$refs.actionCollectionMetaDefault.checked){
            deployTokenRes = await deployBaseCollection()

        }else{
            deployTokenRes = await deployBaseCollection(this.$refs.actionCollectionMeta.value)
        }
          // Rendering the output
          deployTokenRes = !deployTokenRes ? "Failed" :  deployTokenRes;
          this.loadingText = deployTokenRes;
  }

  async function codeBlockSwitchHandler(e){
     if(e.target.innerHTML.includes("everscale-inpage-provider")){
        this.LLdis = "cbHide"
        this.EIPdis = "cbShow"
        this.llAction = "llAction cbHide"
        this.eipAction = "eipAction cbShow"
     }else if(e.target.innerHTML.includes("locklift")){
        this.EIPdis = "cbHide"
        this.LLdis = "cbShow"
        this.llAction = "llAction cbShow"
        this.eipAction = "eipAction cbHide"

     }
  }
return {
        defaultMetaHandler,
        deployCollection,
        codeBlockSwitchHandler
    };
  },
});

</script>


<style>

textarea{
 width:100%;
 height: 400px;
}

.action{
    display:inline-block;
}

.actionInName{
    font-size: .9rem;
}

.deployTokenBut, .Ain, details
{
  background-color: var(--vp-c-bg-mute);
  transition: background-color 0.1s;
  border: 1px solid var(--vp-c-divider);
  border-radius: 8px;
  font-weight: 600;
  cursor : pointer;
}

details{
    padding : 0 10px 0 10px;
}
.Ain{
    padding-left : 10px;
    margin : 0;
}
.deployTokenBut{
    cursor:pointer;
    padding: 5px 12px;
    display: flex;
    transition: all ease .3s;
}

.deployTokenBut:hover{
      border: 1px solid var(--light-color-ts-class);
}

#output-p{
    /* height: 30px; */
    padding: 2px 10px;
    border-radius: 8px;
    border: 1px solid var(--vp-c-divider);
    }

.cbShow{
    display: block;
}
.cbHide{
    display: none;
}

.eipAction{
    font-weight: 600;
}

* {box-sizing: border-box;}

.container {
  display: flex;
  position: relative;
  margin-bottom: 12px;
  font-size: .9rem;
}

.container .checkboxInput {
  position: absolute;
  opacity: 0;
  height: 0;
  width: 0;

}

.checkmark {
  cursor: pointer;
  position: relative;
  top: 0;
  left: 0;
  height: 25px;
  width: 25px;
  background-color: var(--vp-c-bg-mute);
  border: 1px solid var(--vp-c-divider);
  border-radius : 8px;
  margin-left: 10px;
}

.container input:checked ~ .checkmark {
  background-color: var(--vp-c-brand);
}

.checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

.container input:checked ~ .checkmark:after {
  display: block;
}

.container .checkmark:after {
  left: 9px;
  top: 5px;
  width: 5px;
  height: 10px;
  border: solid white;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}

</style>