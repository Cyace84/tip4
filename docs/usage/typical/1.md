# TIP4_1 (Non_fungible Token) Deployment

<div class="deployToken">

In this section will learn how to deploy the most simple part of the standard which is the raw implementation of the `TIP4_1Collection` and `TIP4_1Nft` contract.

Deploying these contracts will provide us the base functionality of the nft contracts on a `TVM(Ton Virtual machine)` based networks and shows us the workflow of the distributed implementation of the nft contracts on these type of blockchains.

We will be expecting base functionality represented by other NFT standard from our collection and nft contracts after deploying them which are containing following operations:

- Deploying the NFTs
- Transferring the NFTs


## Step 1: Prepare the Contracts

### Nft Contract

This contract will be deployed by the `TIP4_1Collection` contract and is the ones which performs the functionalities defined in the `TIp4_1Nft` contract such as transferring the Nfts.

make a file named `Nft.tsol` in the contracts folder and copy the code below into it.

<details>
<summary> show code</summary>

````solidity
pragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;


import '@broxus/tip4/contracts/TIP4_1/TIP4_1Nft.tsol';


contract Nft is TIP4_1Nft {

    constructor(
        address owner,
        address sendGasTo,
        uint128 remainOnNft
    ) TIP4_1Nft(
        owner,
        sendGasTo,
        remainOnNft
    ) public {
        tvm.accept();
    }

}
````

</details>

### Collection Contract

This Contract lets us inherit from the `TIP4_1Collection` contract functionalities which is a abstract contract and also implement the logic for deployments of the NFt contracts.

make a file named `Collection.tsol` in the contracts folder and copy the code below into it.

<details>
<summary> show code</summary>

````solidity

pragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;


import '@broxus/tip4/contracts/access/OwnableExternal.tsol';
import '@broxus/tip4/contracts/TIP4_1/TIP4_1Collection.tsol';
import './Nft.tsol';

contract Collection is TIP4_1Collection, OwnableExternal {

    uint32 static _randomNonce;

    /**
    * Errors
    **/

    uint8 constant sender_is_not_owner = 100;
    uint8 constant value_is_less_than_required = 101;

    /// _remainOnNft - the number of crystals that will remain after the entire mint
    /// process is completed on the Nft contract
    uint128 _remainOnNft = 0.3 ever;

    constructor(
        TvmCell codeNft,
        uint256 ownerPubkey
    ) OwnableExternal (
        ownerPubkey
    ) TIP4_1Collection (
        codeNft
    ) public {
        tvm.accept();
    }

    function mintNft() external virtual {
        require(msg.value > _remainOnNft + 0.1 ever, value_is_less_than_required);
        tvm.rawReserve(0, 4);

        uint256 id = uint256(_totalSupply);
        _totalSupply++;
        TvmCell codeNft = _buildNftCode(address(this));
        TvmCell stateNft = _buildNftState(codeNft, id);
        address nftAddr = new Nft{
            stateInit: stateNft,
            value: 0,
            flag: 128
        }(
            msg.sender,
            msg.sender,
            _remainOnNft
        );

        emit NftCreated(
            id,
            nftAddr,
            msg.sender,
            msg.sender,
            msg.sender
        );

    }

    function setRemainOnNft(uint128 remainOnNft) external virtual {
        require(TIP4_1Collection._isOwner(), sender_is_not_owner);
        _remainOnNft = remainOnNft;
    }

    function _isOwner() internal override onlyOwner returns(bool){
        return true;
    }

    function _buildNftState(
        TvmCell code,
        uint256 id
    ) internal virtual override(TIP4_1Collection) pure returns (TvmCell) {
        return tvm.buildStateInit({
            contr: Nft,
            varInit: {_id: id},
            code: code
        });
    }

}
````

</details>


### Build the Contracts Artifacts

run the command below into your terminal to build the written contracts artifacts:

````shell

npx locklift build

````

### Store Contracts Code and tvc

In order to deploy a contract using the `everscale-inpage-provider` tool we need the target contracts code and tvc.

Copy the build folder generated by the mentioned commend into the scripts folder of your project that using the `everscale-inpage-provider`.

## Step 2: Write Deployment Script

<span  :class="LLdis"  >

Utilize the code sample below to deploy the contracts that we written previously using the `locklift` tool.

::: info
Before we start to write our scripts we need to make sure that there is a file named `01-deploy-tip4-1.ts` in the `script` folder in the project root.
:::

</span>

<span :class="EIPdis"  >

The code sample below is utilized to deploy the mentioned contract using `everscale-inpage-provider` tool.
Two functions are provided with specific duties each, one deploys the collection and the other one deploys the nft contract.

 </span>

<div @click="codeBlockSwitchHandler" >

:::code-group

````typescript [locklift]

import { Signer, Account } from "everscale-standalone-client";
import { Address, WalletTypes } from "locklift";
import { FactorySource } from "../build/factorySource";

async function deployTip4_1() {
  // Fetching the signer key pair from locklift.config.ts
  const signer: Signer = (await locklift.keystore.getSigner("0"))!;

  // uncomment if deploying a new account
  // const { contract: Account } = await locklift.factory.deployContract({
  //   contract: "Account",
  //   publicKey: signer.publicKey,
  //   constructorParams: {},
  //   initParams: { _randomNonce: locklift.utils.getRandomNonce() },
  //   value: locklift.utils.toNano(20),
  // });

  // Adding an existing SafeMultiSig Account using its address
  const account: Account = await locklift.factory.accounts.addExistingAccount({
    type: WalletTypes.MsigAccount,
    address: new Address("YOUR_ACCOUNT_ADDRESS"), // if deploying new account >> Account.address
    mSigType: "SafeMultisig",
    publicKey: signer.publicKey,
  });

  const { contract: collectionContract } = await locklift.factory.deployContract({
    contract: "Collection",
    publicKey: signer.publicKey,
    constructorParams: {
      codeNft: locklift.factory.getContractArtifacts("Nft").code,
      ownerPubkey: `0x${signer.publicKey}`,
    },

    initParams: {
      _randomNonce: locklift.utils.getRandomNonce(),
    },
    value: locklift.utils.toNano(10),
  });

  console.log(`collection deployed to: ${collectionContract.address.toString()}`);

  await collectionContract.methods.mintNft({}).send({ from: account.address, amount: locklift.utils.toNano(2) });

  const nftAddress: Address = (await collectionContract.methods.nftAddress({ answerId: 0, id: 0 }).call({})).nft;

  const nftContract: Contract<FactorySource["Nft"]> = locklift.factory.getDeployedContract("Nft", nftAddress);

  console.log(await nftContract.methods.getInfo({ answerId: 0 }).call());
}
deployTip4_1()
  .then(res => {
    process.exit(0);
  })
  .catch(err => {
    console.log(err);
    process.exit(1);
  });

````

````typescript [everscale-inpage-provider(collection)]
// Import the following libraries
import {
  Address,
  GetExpectedAddressParams,
  Contract,
  ProviderApiResponse,
  FullContractState,
  Transaction,
} from "everscale-inpage-provider";
import { provider, providerAddress } from "../helpers/useProviders";
import { factorySource, FactorySource } from "../build/factorySource";

async function deployTip4_1Collection() {

  try {
    // Collection contract abi
    const collectionAbi: FactorySource["Collection"] =
      factorySource["Collection"];

    // Define the deployParams type
    type DeployParams<Abi> = GetExpectedAddressParams<Abi> & {
      publicKey: string | undefined;
    };

    // Fetching the user public key
    const accountFullState: FullContractState = (
      await provider.getFullContractState({ address: providerAddress })
    ).state!;
    const senderPublicKey: string = await provider.extractPublicKey(
      accountFullState.boc!
    );

    // Fetching the tvc and the code of the nft contract
    const collectionTvc: string = await (
      await fetch("/scripts/build/Collection.base64")
    ).text();
    const nftTvc: string = await (
      await fetch("/scripts/build/Nft.base64")
    ).text();
    const nftCode: string = (await provider.splitTvc(nftTvc)).code!;

    /**
     * Preparing deploy params to build the state init with the contract abi
     */
    const deployParams: DeployParams<FactorySource["Collection"]> = {
      tvc: collectionTvc,
      workchain: 0,
      publicKey: senderPublicKey,
      initParams: {
        _randomNonce: (Math.random() * 6400) | 0,
      },
    };

    // Get the expected contract address
    const expectedAddress: Address = await provider.getExpectedAddress(
      collectionAbi,
      deployParams
    );

    // Get the state init
    const stateInit: ProviderApiResponse<"getExpectedAddress"> =
      await provider.getStateInit(collectionAbi, deployParams);
    stateInit.stateInit;

    // Send the coins to the calculated address
    await provider.sendMessage({
      sender: providerAddress,
      recipient: expectedAddress,
      amount: String(2 * 10 ** 9),
      bounce: false, // it's important to set this param to keep the evers in the contract
      stateInit: stateInit.stateInit,
    });

    // Create a contract instance
    const collectionContract: Contract<FactorySource["Collection"]> =
      new provider.Contract(collectionAbi, expectedAddress);

    // Call the contract constructor
    const { transaction: deployRes } = await collectionContract.methods
      .constructor({
        codeNft: nftCode,
        ownerPubkey: `0x${deployParams.publicKey!}`,
      })
      .sendExternal({
        stateInit: stateInit.stateInit,
        publicKey: deployParams.publicKey!,
      });

    // checking if the collection contract is deployed successfully by calling its name method
    const totalSupply: string = (
      await collectionContract.methods.totalSupply({ answerId: 0 }).call()
    ).count;

    if (totalSupply == "0") {
      console.log(`TIP4_1 collection deployed to ${expectedAddress.toString()}`);
    } else {
      console.log(`TIP4_1 collection deployment failed ! ${
        (deployRes.exitCode, deployRes.resultCode)
      }`);
    }
  } catch (err: any) {
    toast(err.message);
    return err.message;
  }
}
````

````typescript [everscale-inpage-provider(nft)]
 async function deployTip4_1Nft(CollectionAddr: string) {
  try {

    // Collection and the Nft contracts abis
    const collectionAbi: FactorySource["Collection"] =
      factorySource["Collection"];
    const nftAbi: FactorySource["Nft"] = factorySource["Nft"];

    const collectionContract: Contract<FactorySource["Collection"]> =
      new provider.Contract(collectionAbi, new Address(CollectionAddr));

    // deploying an nft from the collection contract
    const totalSupply = Number(
      (await collectionContract.methods.totalSupply({ answerId: 0 }).call())
        .count
    );

    // Minting(deploying) an Nft contract
    const mintRes: Transaction = await collectionContract.methods
      .mintNft({})
      .send({
        from: providerAddress,
        amount: String(2 * 10 ** 9),
        bounce: true,
      });

    // Checking if the Nft contract is deployed successfully
    if (mintRes.aborted)
      return `minting Nft failed ${(mintRes.exitCode, mintRes.resultCode)}`;

    // fetching the newly deployed nft contract
    const nftAddr: Address = (
      await collectionContract.methods
        .nftAddress({
          answerId: 0,
          id: totalSupply + 1,
        })
        .call()
    ).nft;

    const nftContract: Contract<FactorySource["Nft"]> = new provider.Contract(
      nftAbi,
      nftAddr
    );

    // Getting the info of the nft contract ot check the validity of its data
    const nftContractData = await nftContract.methods
      .getInfo({ answerId: 0 })
      .call();

    if (nftContractData.collection.toString() == CollectionAddr.toString()) {
      console.log(`Nft number ${nftContractData.id} deployed to ${nftAddr.toString()}`);
    } else {
      console.log(`TIP4_1 Nft deployment failed ! ${
        (mintRes.exitCode, mintRes.resultCode)
      }`);
    }
  } catch (err: any) {
    console.log(err.message);
    return err.message;
  }
}

````

:::

</div>


<div class="action">

## Step 3: Deploy the NFT

<div :class="llAction">

Use this command to deploy TIP-3 tokens:

```shell
npx locklift run -s ./scripts/01-deploy-tip4-1.ts -n local
```
<ImgContainer src= '/typical01.png' width="100%" altText="deployTip3Output" />

Congratulations, you have successfully deployed your first NFT contract using the `TIP4_1` standard ðŸŽ‰

</div>

<div :class="eipAction" >

<div :class="eipActionCollection">

### Deploy TIP4_1 Collection

<button @click="deployCollection" class="deployTokenBut" >deploy collection</button>

<p id="output-p" :class="EIPdis"><loading :text="loadingText"/></p>

</div>

<div :class="eipActionNft">

### Mint TIP4_1 Nft

<p class=actionInName style="margin-bottom: 0;">Collection Address</p>

<input ref="actionCollectionAddress" class="action Ain" type="text"/>

<button @click="deployNft" class="deployTokenBut" >Mint Nft</button>

<p id="output-p" :class="EIPdis"><loading :text="loadingText2"/></p>

</div>

</div>

</div>

</div>

<script lang="ts" >
import { defineComponent, ref, onMounted } from "vue";
import {toast} from "/src/helpers/toast";
import ImgContainer from "../../../.vitepress/theme/components/shared/BKDImgContainer.vue"
import loading from "../../../.vitepress/theme/components/shared/BKDLoading.vue"
import {deployTip4_1Collection, deployTip4_1Nft} from "../../../scripts/typical/tip4_1";

export default defineComponent({
  name: "deployToken",
      components :{
    ImgContainer,
    loading
  },
  data(){
    return{
        LLdis: "cbShow",
        EIPdis: "cbHide",
        llAction: "llAction cbShow",
        eipAction: "eipAction cbHide",
        eipActionNft: "eipAction cbHide",
        eipActionCollection: "eipAction cbHide",
        loadingText: " ",
        loadingText2: " "
        }
  },
  setup() {

  async function deployCollection(){
          this.loadingText = ""
        let deployTokenRes = await deployTip4_1Collection()
          // Rendering the output
          deployTokenRes = !deployTokenRes ? "Failed" :  deployTokenRes;
          this.loadingText = deployTokenRes;
  }

   async function deployNft(){
          this.loadingText2 = ""
        if (
            this.$refs.actionCollectionAddress.value == ""

        ){
            toast("Collection address field is required !", 0)
            this.loadingText2 = "Failed"
            return
        }

        let deployTokenRes = await deployTip4_1Nft(this.$refs.actionCollectionAddress.value)

          // Rendering the output
          deployTokenRes = !deployTokenRes ? "Failed" :  deployTokenRes;
          this.loadingText2 = deployTokenRes;
  }
  async function codeBlockSwitchHandler(e){
     if(e.target.innerHTML.includes("everscale-inpage-provider(collection)")){
        this.LLdis = "cbHide"
        this.EIPdis = "cbShow"
        this.llAction = "llAction cbHide"
        this.eipAction = "eipAction cbShow"
        this.eipActionNft = "eipAction cbHide"
        this.eipActionCollection = "eipAction cbShow"
     }else if(e.target.innerHTML.includes("everscale-inpage-provider(nft)")){
        this.LLdis = "cbHide"
        this.EIPdis = "cbShow"
        this.llAction = "llAction cbHide"
        this.eipActionCollection = "eipAction cbHide"
        this.eipActionNft = "eipAction cbShow"
     }else if(e.target.innerHTML.includes("locklift")){
        this.EIPdis = "cbHide"
        this.LLdis = "cbShow"
        this.llAction = "llAction cbShow"
        this.eipAction = "eipAction cbHide"

     }
  }
return {
        deployNft,
        deployCollection,
        codeBlockSwitchHandler
    };
  },
});

</script>

<style>

.action{
    display:inline-block;
}

.actionInName{
    font-size: .9rem;
}

.deployTokenBut, .switcherContainer, .codeBlockContainer, .Ain, details
{
  background-color: var(--vp-c-bg-mute);
  transition: background-color 0.1s;
  border: 1px solid var(--vp-c-divider);
  border-radius: 8px;
  font-weight: 600;
  cursor : pointer;
}

details{
    padding : 0 10px 0 10px;
}
.Ain{
    padding-left : 10px;
    margin : 0;
}
.deployTokenBut{
    cursor:pointer;
    padding: 5px 12px;
    display: flex;
    transition: all ease .3s;
}

.deployTokenBut:hover{
      border: 1px solid var(--light-color-ts-class);
}

#output-p{
    /* height: 30px; */
    padding: 2px 10px;
    border-radius: 8px;
    border: 1px solid var(--vp-c-divider);
    }

.text{padding-left: 5px;font-size:1rem;}

.switcherContainer{
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    display: flex;
    border: none;
    padding: 0px;
}
.switcherContainer > p{
    margin: 0px;
    padding : 0px;
}
.codeBlockContainer{
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    padding: 8px 12px;
}
.cbShow{
    display: block;
}
.cbHide{
    display: none;
}
.llSwitcher{
    padding: 5px 10px;
    border:  0 solid var(--vp-c-divider);
    border-width: 1px ;
    border-color: var(--vp-c-divider);
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    font-weight: 600;
    transition: all ease .2s;
}
.eipSwitcher{
    padding: 5px 10px;
    border:  0 solid var(--vp-c-divider);
    border-width: 1px ;
    border-color: var(--vp-c-divider);
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    font-weight: 600;
    transition: all ease .2s;
}
.llSwitcher:hover, .eipSwitcher:hover{
      border-color: var(--light-color-ts-class);
}
.eipAction{
    font-weight: 600;
}
.on{
    color : var(--light-color-ts-class);
}
.off{
    color : var(--vp-c-bg-mute);
}

* {box-sizing: border-box;}

.container {
  display: flex;
  position: relative;
  margin-bottom: 12px;
  font-size: .9rem;
}

.container .checkboxInput {
  position: absolute;
  opacity: 0;
  height: 0;
  width: 0;

}

.checkmark {
  cursor: pointer;
  position: relative;
  top: 0;
  left: 0;
  height: 25px;
  width: 25px;
  background-color: var(--vp-c-bg-mute);
  border: 1px solid var(--vp-c-divider);
  border-radius : 8px;
  margin-left: 10px;
}

.container input:checked ~ .checkmark {
  background-color: var(--light-color-ts-class);
}

.checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

.container input:checked ~ .checkmark:after {
  display: block;
}

.container .checkmark:after {
  left: 9px;
  top: 5px;
  width: 5px;
  height: 10px;
  border: solid white;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}

</style>